{"ast":null,"code":"\"use strict\";\n\nconst EARTH_RADIUS = 6371000; // meters\n\nconst DEG_TO_RAD = Math.PI / 180.0;\nconst THREE_PI = Math.PI * 3;\nconst TWO_PI = Math.PI * 2;\nconst toRadians = deg => deg * DEG_TO_RAD;\nconst toDegrees = rad => rad / DEG_TO_RAD;\n/*\nGiven a centerPoint C and a radius R, returns a random point that is on the\ncircumference defined by C and R.\n\ncenterPoint C is of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nradius R is in meters.\n\nBased on: http://www.movable-type.co.uk/scripts/latlong.html#destPoint\n*/\n\nconst randomCircumferencePoint = (centerPoint, radius, randomFn = Math.random) => {\n  const sinLat = Math.sin(toRadians(centerPoint.latitude));\n  const cosLat = Math.cos(toRadians(centerPoint.latitude)); // Random bearing (direction out 360 degrees)\n\n  const bearing = randomFn() * TWO_PI;\n  const sinBearing = Math.sin(bearing);\n  const cosBearing = Math.cos(bearing); // Theta is the approximated angular distance\n\n  const theta = radius / EARTH_RADIUS;\n  const sinTheta = Math.sin(theta);\n  const cosTheta = Math.cos(theta);\n  let rLatitude, rLongitude;\n  rLatitude = Math.asin(sinLat * cosTheta + cosLat * sinTheta * cosBearing);\n  rLongitude = toRadians(centerPoint.longitude) + Math.atan2(sinBearing * sinTheta * cosLat, cosTheta - sinLat * Math.sin(rLatitude)); // Normalize longitude L such that -PI < L < +PI\n\n  rLongitude = (rLongitude + THREE_PI) % TWO_PI - Math.PI;\n  return {\n    latitude: toDegrees(rLatitude),\n    longitude: toDegrees(rLongitude)\n  };\n};\n/*\nGiven a centerPoint C and a radius R, returns a random point that is inside\nthe circle defined by C and R.\n\ncenterPoint C is of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nradius R is in meters.\n*/\n\nconst randomCirclePoint = (centerPoint, radius, randomFn = Math.random) => {\n  // http://mathworld.wolfram.com/DiskPointPicking.html\n  return randomCircumferencePoint(centerPoint, Math.sqrt(randomFn()) * radius, randomFn);\n};\n/**\n * Returns a random point in a region bounded by two concentric circles (annulus).\n *\n * centerPoint - the center point of both circles.\n * innerRadius - the radius of the smaller circle.\n * outerRadius - the radius of the larger circle\n * randomFn -  *optional* A random function. Output is >=0 and <=1. Allows\n * usage of seeded random number generators - i.e. allows us to predict\n * generated random coordiantes. default is Math.random()\n *\n */\n\nconst randomAnnulusPoint = (centerPoint, innerRadius, outerRadius, randomFn = Math.random) => {\n  if (innerRadius >= outerRadius) {\n    throw new Error(`innerRadius (${innerRadius}) should be smaller than outerRadius (${outerRadius})`);\n  }\n  const deltaRadius = outerRadius - innerRadius;\n  return randomCircumferencePoint(centerPoint, innerRadius + Math.sqrt(randomFn()) * deltaRadius, randomFn);\n};\n/*\nReturns the distance in meters between two points P1 and P2.\n\nP1 and P2 are of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nBasically it is the Haversine distance function.\nBased on: http://www.movable-type.co.uk/scripts/latlong.html\n*/\n\nconst distance = (P1, P2) => {\n  const rP1 = {\n    latitude: toRadians(P1.latitude),\n    longitude: toRadians(P1.longitude)\n  };\n  const rP2 = {\n    latitude: toRadians(P2.latitude),\n    longitude: toRadians(P2.longitude)\n  };\n  const D = {\n    latitude: Math.sin((rP2.latitude - rP1.latitude) / 2),\n    longitude: Math.sin((rP2.longitude - rP1.longitude) / 2)\n  };\n  const A = D.latitude * D.latitude + D.longitude * D.longitude * Math.cos(rP1.latitude) * Math.cos(rP2.latitude);\n  const C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1 - A));\n  return EARTH_RADIUS * C;\n};\nconst haversine = distance;\nmodule.exports = {\n  distance,\n  haversine,\n  randomCircumferencePoint,\n  randomCirclePoint,\n  randomAnnulusPoint\n};","map":{"version":3,"names":["EARTH_RADIUS","DEG_TO_RAD","Math","PI","THREE_PI","TWO_PI","toRadians","deg","toDegrees","rad","randomCircumferencePoint","centerPoint","radius","randomFn","random","sinLat","sin","latitude","cosLat","cos","bearing","sinBearing","cosBearing","theta","sinTheta","cosTheta","rLatitude","rLongitude","asin","longitude","atan2","randomCirclePoint","sqrt","randomAnnulusPoint","innerRadius","outerRadius","Error","deltaRadius","distance","P1","P2","rP1","rP2","D","A","C","haversine","module","exports"],"sources":["C:/Dev/vue-3-router/02/demos/02_03/node_modules/random-location/dist/index.js"],"sourcesContent":["\"use strict\";\n\nconst EARTH_RADIUS = 6371000; // meters\n\nconst DEG_TO_RAD = Math.PI / 180.0;\nconst THREE_PI = Math.PI * 3;\nconst TWO_PI = Math.PI * 2;\n\nconst toRadians = deg => deg * DEG_TO_RAD;\n\nconst toDegrees = rad => rad / DEG_TO_RAD;\n/*\nGiven a centerPoint C and a radius R, returns a random point that is on the\ncircumference defined by C and R.\n\ncenterPoint C is of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nradius R is in meters.\n\nBased on: http://www.movable-type.co.uk/scripts/latlong.html#destPoint\n*/\n\n\nconst randomCircumferencePoint = (centerPoint, radius, randomFn = Math.random) => {\n  const sinLat = Math.sin(toRadians(centerPoint.latitude));\n  const cosLat = Math.cos(toRadians(centerPoint.latitude)); // Random bearing (direction out 360 degrees)\n\n  const bearing = randomFn() * TWO_PI;\n  const sinBearing = Math.sin(bearing);\n  const cosBearing = Math.cos(bearing); // Theta is the approximated angular distance\n\n  const theta = radius / EARTH_RADIUS;\n  const sinTheta = Math.sin(theta);\n  const cosTheta = Math.cos(theta);\n  let rLatitude, rLongitude;\n  rLatitude = Math.asin(sinLat * cosTheta + cosLat * sinTheta * cosBearing);\n  rLongitude = toRadians(centerPoint.longitude) + Math.atan2(sinBearing * sinTheta * cosLat, cosTheta - sinLat * Math.sin(rLatitude)); // Normalize longitude L such that -PI < L < +PI\n\n  rLongitude = (rLongitude + THREE_PI) % TWO_PI - Math.PI;\n  return {\n    latitude: toDegrees(rLatitude),\n    longitude: toDegrees(rLongitude)\n  };\n};\n/*\nGiven a centerPoint C and a radius R, returns a random point that is inside\nthe circle defined by C and R.\n\ncenterPoint C is of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nradius R is in meters.\n*/\n\n\nconst randomCirclePoint = (centerPoint, radius, randomFn = Math.random) => {\n  // http://mathworld.wolfram.com/DiskPointPicking.html\n  return randomCircumferencePoint(centerPoint, Math.sqrt(randomFn()) * radius, randomFn);\n};\n/**\n * Returns a random point in a region bounded by two concentric circles (annulus).\n *\n * centerPoint - the center point of both circles.\n * innerRadius - the radius of the smaller circle.\n * outerRadius - the radius of the larger circle\n * randomFn -  *optional* A random function. Output is >=0 and <=1. Allows\n * usage of seeded random number generators - i.e. allows us to predict\n * generated random coordiantes. default is Math.random()\n *\n */\n\n\nconst randomAnnulusPoint = (centerPoint, innerRadius, outerRadius, randomFn = Math.random) => {\n  if (innerRadius >= outerRadius) {\n    throw new Error(`innerRadius (${innerRadius}) should be smaller than outerRadius (${outerRadius})`);\n  }\n\n  const deltaRadius = outerRadius - innerRadius;\n  return randomCircumferencePoint(centerPoint, innerRadius + Math.sqrt(randomFn()) * deltaRadius, randomFn);\n};\n/*\nReturns the distance in meters between two points P1 and P2.\n\nP1 and P2 are of type { latitude: A, longitude: B }\nWhere -90 <= A <= 90 and -180 <= B <= 180.\n\nBasically it is the Haversine distance function.\nBased on: http://www.movable-type.co.uk/scripts/latlong.html\n*/\n\n\nconst distance = (P1, P2) => {\n  const rP1 = {\n    latitude: toRadians(P1.latitude),\n    longitude: toRadians(P1.longitude)\n  };\n  const rP2 = {\n    latitude: toRadians(P2.latitude),\n    longitude: toRadians(P2.longitude)\n  };\n  const D = {\n    latitude: Math.sin((rP2.latitude - rP1.latitude) / 2),\n    longitude: Math.sin((rP2.longitude - rP1.longitude) / 2)\n  };\n  const A = D.latitude * D.latitude + D.longitude * D.longitude * Math.cos(rP1.latitude) * Math.cos(rP2.latitude);\n  const C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1 - A));\n  return EARTH_RADIUS * C;\n};\n\nconst haversine = distance;\nmodule.exports = {\n  distance,\n  haversine,\n  randomCircumferencePoint,\n  randomCirclePoint,\n  randomAnnulusPoint\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}